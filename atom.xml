<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alfy20.github.io</id>
    <title>Gridea</title>
    <updated>2020-08-31T06:44:34.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://alfy20.github.io"/>
    <link rel="self" href="http://alfy20.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://alfy20.github.io/images/avatar.png</logo>
    <icon>http://alfy20.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[ES5、ES6、ES7 笔记]]></title>
        <id>http://alfy20.github.io/post/es5es6es7-bi-ji/</id>
        <link href="http://alfy20.github.io/post/es5es6es7-bi-ji/">
        </link>
        <updated>2020-08-31T06:18:38.000Z</updated>
        <summary type="html"><![CDATA[<p><img src="http://alfy20.github.io/post-images/1598855801819.webp" alt="" loading="lazy"># ES5、6、7</p>
<p>ES的几个重要版本</p>
<ul>
<li>ES5：09年发布</li>
<li>ES6(ES2015)：15年发布</li>
<li>ES7(ES2016)：16年发布(变化不大)</li>
</ul>
<h2 id="一-es5">一、ES5</h2>
<h3 id="11-严格模式">1.1 严格模式</h3>
<p>除了正常运行模式，ES5 添加了第二种模式“严格模式”，使得 JS 在更严格的语法条件下运行。</p>
<p>目的：消除 JS 语法的不合理/不严谨/不安全之处，为代码的安全运行保驾护航。</p>
<p>使用：</p>
<ul>
<li>在全局或函数的第一条语句定义为：'use strict'</li>
<li>如果浏览器不支持，只解析为一条简单的语句，没有任何副作用</li>
</ul>
<p>语法和行为改变：</p>
<ul>
<li>必须使用 var 声明变量</li>
<li>禁止自定义的函数中的 this 指向 window</li>
</ul>
<pre><code class="language-javascript">

'use strict'
function Person(name, age) {
  this.name = name;
  this.age = age;
}
new Person('kb', 39)// 不加上new
// 报错Uncaught TypeError: Cannot set property 'name' of undefined

new Person('kb', 39) // 加上new
// 不报错Person {name: &quot;kb&quot;, age: 39}
</code></pre>
<blockquote>
<p>因为此时 Person 中的 this 指向的是 window；只有加上 new，this 才指向 new 出来的一个实例对象</p>
</blockquote>
<ul>
<li>创建 eval 作用域(目前不推荐使用)</li>
<li>对象不能有重名的属性</li>
</ul>
<h3 id="12-json-对象">1.2 JSON 对象</h3>
<ol>
<li>
<p>JSON.stringify(obj/arr)</p>
<p>将 js 对象(数组)转换为 json 对象(数组)</p>
</li>
<li>
<p>JSON.parse(json)</p>
<p>将 json 对象(数组)转换为 js 对象(数组)</p>
</li>
</ol>
<pre><code class="language-javascript">var obj = {username: 'kb'}; // 创建一个js对象

obj = JSON.stringify(obj); // 转换成JSON对象
console.log(obj) // {&quot;username&quot;:&quot;kb&quot;}
console.log(typeof obj) // string

obj = JSON.parse(obj) // 转换成JS对象
console.log(obj) // {username: &quot;kb&quot;}
console.log(typeof obj) // object
</code></pre>
<h3 id="13-object-对象方法扩展">1.3 Object 对象方法扩展</h3>
<p>ES5 给 Object 扩展了一些静态方法，常用的2个：</p>
<h4 id="objectcreateprototype-descriptors">object.create(prototype, [descriptors])</h4>
<p>作用：以指定对象为原型创建新的对象</p>
<p>为新的对象指定新的属性，并对实行进行描述</p>
<ul>
<li>value：指定值</li>
<li>writable：标识当前属性值是否可修改，默认为false</li>
<li>configurable：标识当前属性是否可以被删除，默认为false</li>
<li>enumerable：标识当前属性是否能用for in 枚举，默认为false</li>
</ul>
<pre><code class="language-javascript">var obj = {username: 'dm', age: 30};
var obj1 = {};
obj1 = Object.create(obj, {
  sex: { // 扩展的新属性
    value: 'male',
    writable: true, // 只有指定writable为true才能修改sex的值
    configurable: true, // 只有指定configurable为true才能删除sex的值
    enumerable: true // 只有指定enumerable为true才能枚举sex的值
  },

});
console.log(obj1.age); // 30
console.log(obj1);
/*
  sex: &quot;male&quot;
 &gt;__proto__:
    age: 30
    username: &quot;dm&quot;
*/
console.log(obj1.sex); // male
obj1.sex = 'female';
console.log(obj1.sex); // female
//delete obj1.sex;
//console.log(obj1.sex); // undefined
for(var i in obj1) {
  console.log(i) // sex也能打印出来
}
</code></pre>
<h4 id="objectdefinepropertiesobject-descriptors">Object.defineProperties(object, descriptors)</h4>
<p>作用：为指定对象定义扩展多个属性</p>
<p>get：用来获取当前<strong>属性值</strong>的回调函数</p>
<p>set：监听当前<strong>属性值</strong>的回调函数(属性值发生变化会自动调用)，调用后会将修改后的值作为实参注入到 set 函数</p>
<p>存取器属性：setter，getter 一个用来存值，一个用来取值</p>
<pre><code class="language-javascript">var obj2 = {firstName: 'kb', lastName: 'brt'};
Object.defineProperties(obj2, {
  fullName: {
    get: function() { // 获取当前扩展属性的值的回调函数，每次获取属性值时get方法自动调用
      console.log('get()');
      return this.firstName + ' ' + this.lastName;
    },
    set: function(data) { // 监听当前扩展属性，只有当他发生变化时才自动调用(data就是想要修改成的值)
      console.log('set()', data) // set() tim dc
      var names = data.split(' '); // 不能直接改变fullName的值但是可以通过这种方式间接改变
      this.firstName = names[0];
      this.lastName = names[1];
    }
  }
})

console.log(obj2.fullName)
obj2.fullName = 'tim dc' // 修改fullName属性的值
console.log(obj2.fullName)
// get()
// kb ret
// set(), tim dc
// get()
// tim dc
</code></pre>
<h4 id="对象本身的两个方法">对象本身的两个方法</h4>
<p>get propertyName() {}：用来得到当前属性值的回调函数</p>
<p>set propertyName() {} ：用来监听当前属性值变化的回调函数</p>
<pre><code class="language-javascript">var obj = {
  firstName: 'cr',
  lastName: 'stp',
  get fullName() {
    return this.firstName + ' ' + this.lastName;
  },
  set fullName(data) {
    var names = data.split(' ');
    this.firstName = names[0];
    this.lastName = names[1];
  }
};
console.log(obj);
obj.fullName = 'kb brt';
console.log(obj.fullName);
</code></pre>
<p><strong>这两种写法不同但是结果是完全相同的。</strong></p>
<h3 id="14-array-扩展">1.4 Array 扩展</h3>
]]></summary>
        <content type="html"><![CDATA[<p><img src="http://alfy20.github.io/post-images/1598855801819.webp" alt="" loading="lazy"># ES5、6、7</p>
<p>ES的几个重要版本</p>
<ul>
<li>ES5：09年发布</li>
<li>ES6(ES2015)：15年发布</li>
<li>ES7(ES2016)：16年发布(变化不大)</li>
</ul>
<h2 id="一-es5">一、ES5</h2>
<h3 id="11-严格模式">1.1 严格模式</h3>
<p>除了正常运行模式，ES5 添加了第二种模式“严格模式”，使得 JS 在更严格的语法条件下运行。</p>
<p>目的：消除 JS 语法的不合理/不严谨/不安全之处，为代码的安全运行保驾护航。</p>
<p>使用：</p>
<ul>
<li>在全局或函数的第一条语句定义为：'use strict'</li>
<li>如果浏览器不支持，只解析为一条简单的语句，没有任何副作用</li>
</ul>
<p>语法和行为改变：</p>
<ul>
<li>必须使用 var 声明变量</li>
<li>禁止自定义的函数中的 this 指向 window</li>
</ul>
<pre><code class="language-javascript">

'use strict'
function Person(name, age) {
  this.name = name;
  this.age = age;
}
new Person('kb', 39)// 不加上new
// 报错Uncaught TypeError: Cannot set property 'name' of undefined

new Person('kb', 39) // 加上new
// 不报错Person {name: &quot;kb&quot;, age: 39}
</code></pre>
<blockquote>
<p>因为此时 Person 中的 this 指向的是 window；只有加上 new，this 才指向 new 出来的一个实例对象</p>
</blockquote>
<ul>
<li>创建 eval 作用域(目前不推荐使用)</li>
<li>对象不能有重名的属性</li>
</ul>
<h3 id="12-json-对象">1.2 JSON 对象</h3>
<ol>
<li>
<p>JSON.stringify(obj/arr)</p>
<p>将 js 对象(数组)转换为 json 对象(数组)</p>
</li>
<li>
<p>JSON.parse(json)</p>
<p>将 json 对象(数组)转换为 js 对象(数组)</p>
</li>
</ol>
<pre><code class="language-javascript">var obj = {username: 'kb'}; // 创建一个js对象

obj = JSON.stringify(obj); // 转换成JSON对象
console.log(obj) // {&quot;username&quot;:&quot;kb&quot;}
console.log(typeof obj) // string

obj = JSON.parse(obj) // 转换成JS对象
console.log(obj) // {username: &quot;kb&quot;}
console.log(typeof obj) // object
</code></pre>
<h3 id="13-object-对象方法扩展">1.3 Object 对象方法扩展</h3>
<p>ES5 给 Object 扩展了一些静态方法，常用的2个：</p>
<h4 id="objectcreateprototype-descriptors">object.create(prototype, [descriptors])</h4>
<p>作用：以指定对象为原型创建新的对象</p>
<p>为新的对象指定新的属性，并对实行进行描述</p>
<ul>
<li>value：指定值</li>
<li>writable：标识当前属性值是否可修改，默认为false</li>
<li>configurable：标识当前属性是否可以被删除，默认为false</li>
<li>enumerable：标识当前属性是否能用for in 枚举，默认为false</li>
</ul>
<pre><code class="language-javascript">var obj = {username: 'dm', age: 30};
var obj1 = {};
obj1 = Object.create(obj, {
  sex: { // 扩展的新属性
    value: 'male',
    writable: true, // 只有指定writable为true才能修改sex的值
    configurable: true, // 只有指定configurable为true才能删除sex的值
    enumerable: true // 只有指定enumerable为true才能枚举sex的值
  },

});
console.log(obj1.age); // 30
console.log(obj1);
/*
  sex: &quot;male&quot;
 &gt;__proto__:
    age: 30
    username: &quot;dm&quot;
*/
console.log(obj1.sex); // male
obj1.sex = 'female';
console.log(obj1.sex); // female
//delete obj1.sex;
//console.log(obj1.sex); // undefined
for(var i in obj1) {
  console.log(i) // sex也能打印出来
}
</code></pre>
<h4 id="objectdefinepropertiesobject-descriptors">Object.defineProperties(object, descriptors)</h4>
<p>作用：为指定对象定义扩展多个属性</p>
<p>get：用来获取当前<strong>属性值</strong>的回调函数</p>
<p>set：监听当前<strong>属性值</strong>的回调函数(属性值发生变化会自动调用)，调用后会将修改后的值作为实参注入到 set 函数</p>
<p>存取器属性：setter，getter 一个用来存值，一个用来取值</p>
<pre><code class="language-javascript">var obj2 = {firstName: 'kb', lastName: 'brt'};
Object.defineProperties(obj2, {
  fullName: {
    get: function() { // 获取当前扩展属性的值的回调函数，每次获取属性值时get方法自动调用
      console.log('get()');
      return this.firstName + ' ' + this.lastName;
    },
    set: function(data) { // 监听当前扩展属性，只有当他发生变化时才自动调用(data就是想要修改成的值)
      console.log('set()', data) // set() tim dc
      var names = data.split(' '); // 不能直接改变fullName的值但是可以通过这种方式间接改变
      this.firstName = names[0];
      this.lastName = names[1];
    }
  }
})

console.log(obj2.fullName)
obj2.fullName = 'tim dc' // 修改fullName属性的值
console.log(obj2.fullName)
// get()
// kb ret
// set(), tim dc
// get()
// tim dc
</code></pre>
<h4 id="对象本身的两个方法">对象本身的两个方法</h4>
<p>get propertyName() {}：用来得到当前属性值的回调函数</p>
<p>set propertyName() {} ：用来监听当前属性值变化的回调函数</p>
<pre><code class="language-javascript">var obj = {
  firstName: 'cr',
  lastName: 'stp',
  get fullName() {
    return this.firstName + ' ' + this.lastName;
  },
  set fullName(data) {
    var names = data.split(' ');
    this.firstName = names[0];
    this.lastName = names[1];
  }
};
console.log(obj);
obj.fullName = 'kb brt';
console.log(obj.fullName);
</code></pre>
<p><strong>这两种写法不同但是结果是完全相同的。</strong></p>
<h3 id="14-array-扩展">1.4 Array 扩展</h3>
<!-- more -->
<p>Array.prototype.indexOf(value)：得到值在数组中的第一个下标</p>
<p>Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标</p>
<p>Array.prototype.forEach(function(item, index) {})：遍历数组</p>
<p>Array.prototype.map(function(item, index) {})：遍历数组返回一个新的数组，返回加工之后的值</p>
<p>Array.prototype.filter(function(item, index) {})：遍历过滤出一个新的子数组，返回条件为true的值</p>
<pre><code class="language-javascript">// 输出第一个6的下标
// 输出最后一个6的下标
// 输出所有元素的值和下标
// 根据arr产生一个新数组，要求每个元素都比原来大10
// 根据arr产生一个新数组，返回的每个元素要大于4
var arr = [5,7,6,4,5,1,6,2,3,8]
console.log(arr.indexOf(6))
console.log(arr.lastIndexOf(6))
arr.forEach((item, index) =&gt; {
  console.log(item, index)
})
var arr1 = arr.map(item =&gt; {
  return item + 10
})
console.log(arr1)
var arr2 = arr.filter(item =&gt; {
  return item &gt; 4
})
console.log(arr2)
</code></pre>
<h3 id="15-function-扩展call-apply-bind用法详解">1.5 Function 扩展——call、apply、bind用法详解</h3>
<p>Function.prototype.bind(obj)：将函数内的 this 绑定为 obj，并将函数返回</p>
<p>区别 bind()、call() 和 apply()：</p>
<p>都能指定函数中的 this</p>
<p>call()/apply() 是立即调用函数，bind() 是将函数返回</p>
<pre><code>var obj = {username: 'wy'};
function foo() {
    console.log(this)
}
foo() // window
foo.call(obj) // {username: &quot;wy&quot;}
foo.apply(obj) // {username: &quot;wy&quot;}
</code></pre>
<blockquote>
<p>不传参时，call 和 apply 的用法相同。</p>
</blockquote>
<p>传入参数的形式不同：</p>
<pre><code>var obj = {username: 'wy'};
function foo(data) {
    console.log(this, data)
}
foo.call(obj, 33) // {username: &quot;wy&quot;} 33
foo.apply(obj, [33]) // {username: &quot;wy&quot;} 33
</code></pre>
<blockquote>
<p>call：直接从第二个参数开始，依次传入</p>
<p>apply：第二参数必须是数组，传入值放在数组里</p>
</blockquote>
<pre><code>var obj = {username: 'wy'}
function foo(data) {
    console.log(this, data)
}
foo.bind(obj, 33) // 没有输出
foo.bind(obj, 33)() // {username: &quot;wy&quot;} 33
</code></pre>
<blockquote>
<p>bind 的特点：绑定完 this 不会立即调用当前的函数，而是将函数返回。</p>
<p>传参的方式和 call 一样</p>
</blockquote>
<p>什么时候用 bind：</p>
<pre><code>var obj = {username: 'wy'}
setTimeout(function() {
  console.log(this)
}.bind(obj), 1000)
</code></pre>
<h2 id="二-es6">二、ES6</h2>
<h3 id="21-常用">2.1 常用</h3>
<h4 id="211-let-const-关键字">2.1.1 let、const 关键字</h4>
<p>let：声明一个变量</p>
<ul>
<li>在块级作用域内有效</li>
<li>不能重复声明</li>
<li>不会预处理，不存在变量提升</li>
</ul>
<p>const：定义一个常量</p>
<ul>
<li>不能修改</li>
<li>其他特点同 let</li>
</ul>
<h5 id="var-let-const-的区别">var、let、const 的区别</h5>
<ol>
<li>var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li>
<li>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>
<li>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>
</ol>
<h4 id="212-变量的解构赋值">2.1.2 变量的解构赋值</h4>
<p>从对象或数组中提取数组，并赋值给变量（多个）</p>
<p>对象的解构赋值：</p>
<p>let {n, a} = {n: 'tom', a:12}</p>
<p>数组的解构赋值：</p>
<p>let [a, b] = [1, 'atguigu']</p>
<p>用途</p>
<p>给多个形参赋值</p>
<h5 id="获取数组中的值">获取数组中的值</h5>
<pre><code>var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];

var [a, b, c] = foo;
console.log(a); // &quot;one&quot;
console.log(b); // &quot;two&quot;
console.log(c); // &quot;three&quot;
// or
var a, b;
[a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2
</code></pre>
<h5 id="获取对象中的值">获取对象中的值</h5>
<pre><code>const student = {
  name: 'Ming',
  age: 18,
  city: 'Shanghai'
}

const {name, age, city} = student;
console.log(name); // 'Ming'
console.log(age); // 18
console.log(city); // 'Shanghai'
</code></pre>
<h4 id="213-模板字符串">2.1.3 模板字符串</h4>
<p>简化字符串的拼接</p>
<ul>
<li>必须用``包含</li>
<li>变化的部分使用 ${xxx} 定义</li>
</ul>
<pre><code>var name = 'Your name is ' + first + ' ' + last + '.'
// 使用模板字符串
var name = `Your name is ${first} ${last}.`
</code></pre>
<h4 id="214-对象的简写方式">2.1.4 对象的简写方式</h4>
<p>省略同名的属性值</p>
<p>省略方法的function</p>
<pre><code>const name='Ming', age='18', city='Shanghai';
//ES5
const student = {
    name: name,
    age: age,
    city: city,
      getName: function() {
&lt;!-- more --&gt;

      return this.name;
    }
};

//ES6
const student = {
    name, // 同名的属性可以省略不写
    age,
    city,
      getName() { // 可以省略函数的function
      return this.name;
    }
};
console.log(student);//{name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;}
console.log(student.getName()); // Ming
</code></pre>
<h4 id="215-箭头函数">2.1.5 箭头函数</h4>
<p>作用：定义匿名函数</p>
<p>语法：</p>
<ul>
<li>没有参数：() =&gt; console.log('xxxx')</li>
<li>一个参数：i =&gt; i+2</li>
<li>大于一个参数：(i, j) =&gt; i+j</li>
<li>函数体不用大括号：默认返回结果</li>
<li>函数体如果有多个语句，需要用{}包围，若有需要返回的内容，需要手动 return 返回</li>
</ul>
<p>使用场景：多用于定义回调函数</p>
<pre><code>// 形参的情况
// 1.没有形参的时候
let fun1 = () =&gt; console.log('我是箭头函数')
fun1()
// 2.只有一个形参的时候，()可以省略
let fun2 = a =&gt; console.log(a)
fun2('aaa')
// 3.两个及两个以上形参的时候，()不能省略
let fun3 = (x, y) =&gt; console.log(x, y)
fun3(25, 35)
// 函数体的情况
// 1.函数体只有一条语句或表达式的时候，{}可以省略--&gt;会自动返回（return）语句/表达式的结果
fun4 = (x, y) =&gt; x + y
console.log(fun4(24, 36))

// 2.函数体不止一条语句或表达式的时候，{}不可以省略
let fun5 = (x, y) =&gt; {
  console.log(x, y)
  return x + y
}
console.log(fun5(20, 30))
</code></pre>
<p>箭头函数的特点：</p>
<ol>
<li>箭头函数没有自己 this，箭头函数的 this 不是调用的时候决定的，而是在定义的时候处在的对象就是它的 this（这个规则与常规函数的 this 指向相反）</li>
<li>扩展理解：箭头函数的 this 看外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window</li>
</ol>
<pre><code>&lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;btn2&lt;/button&gt;

let btn1 = document.getElementById('btn1')
let btn2 = document.getElementById('btn2')

btn1.onclick = function() {
  console.log(this) // [object HTMLbuttonElement]
}
btn2.onclick = () =&gt; {
  console.log(this) // [object Window]
}
</code></pre>
<p>将箭头函数改为外层有函数的形式：</p>
<pre><code>var obj = {
  name: '箭头函数',
  getNmae() {
    btn2.onclick = () =&gt; {
          console.log(this.name) // 箭头函数
        }
  }
}
// 此时箭头函数中的this指向这个obj
</code></pre>
<p>再举个栗子：</p>
<pre><code>let a = {
  b: 'wy',
  c() {
    let d = () =&gt; {
      console.log(this.b)
    }
    return d // 注意一定要有这个return
  }
}
let b = 'ss'
a.c()() // wy
</code></pre>
<p>箭头函数外层有函数c，和函数c的 this 一样。</p>
<pre><code>var a = {
    b: 'wy',
    c: () =&gt; {
        console.log(this.b)
    }
}
var b = 'ss'
a.c() // ss
</code></pre>
<p>由于箭头函数外没有函数，所以this指向window</p>
<h4 id="216-三点运算符">2.1.6 三点运算符</h4>
<p>用途</p>
<p>1.rest（不定/可变）参数</p>
<p>用来取代 arguments，但比 arguments 灵活，只能是最后部分形参参数</p>
<pre><code>function foo(a, ...value) {
  console.log(value) // [7, 45, 22]
}
foo(5, 7, 45, 22)
</code></pre>
<blockquote>
<p>不定参数 value 会返回一个数组，可以用数组的所有方法；而 arguments 只是伪数组，没有数组的各种方法。</p>
</blockquote>
<p>2.扩展运算符</p>
<pre><code>let arr = [1, 6]
let arr1 = [2, 3, 4, 5]
arr = [1, ...arr1, 6]
console.log(...arr) //[1, 2, 3, 4, 5, 6]
</code></pre>
<p>相当于会自动遍历这个数组，拿到每一项值</p>
<h4 id="217-形参默认值">2.1.7 形参默认值</h4>
<p>当不传入参数的时候默认使用形参里的默认值</p>
<pre><code>function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}
let point = new Point(23, 35)
console.log(point) // {x:23, y:35}
let point2 = new Point() // 不传参数
console.log(point) // {x:0, y:0}
</code></pre>
<h4 id="218-promise-对象">2.1.8 Promise 对象</h4>
<ol>
<li>
<p>Promise 对象：代表了未来某个将要发生的事件（通常是一个异步操作）</p>
<p>有了 promise 对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（回调地狱）</p>
<p>ES6的 Promise 是一个构造函数，用来生成 Promise 实例</p>
</li>
<li>
<p>使用 promise 基本步骤（2步）：</p>
<ul>
<li>创建 promise 对象</li>
<li>调用 promise 的 then()</li>
</ul>
</li>
<li>
<p>promise 对象的3个状态</p>
<ul>
<li>pending ：初始化状态</li>
<li>fullfilled（resolved）：成功状态</li>
<li>rejected：失败状态</li>
</ul>
</li>
<li>
<p>应用</p>
<ul>
<li>使用 promise 实现超时处理</li>
<li>使用 promise 封装处理 ajax 请求</li>
</ul>
</li>
</ol>
<pre><code>const p = new Promise((resolve, reject) =&gt; { // 同步执行
  // 初始化promise状态：pending
  console.log(111)
  // 执行异步操作，通常是发送ajax请求 或 开启定时器
  setTimeout(() =&gt; {
    console.log(333)
    // 根据异步任务的返回结果来去修改promise的状态
    // 异步任务成功
    resolve('xixi'); // 修改promise的状态为fullfilled（成功的状态）
    // 异步任务失败
    //reject('555') // 修改promise的状态为rejected（失败的状态）
  }, 1000)
})
console.log(222)
p.then(
  value =&gt; { // 成功的回调
      console.log('成功了',value)
  },
  reason =&gt; { // 失败的回调
      console.log('失败了',reason)
  }
)
</code></pre>
<p>下面是一个案例练习</p>
<p>需求：</p>
<ol>
<li>发送 ajax 请求获取新闻内容</li>
<li>新闻内容获取成功后再次发送请求，获取对应的新闻评论内容</li>
<li>新闻内容获取失败则不需要再次发送请求</li>
</ol>
<pre><code>// 定义获取新闻的功能函数
function getData(url) {
  let promise = new Promise((resolve, reject) =&gt; {
    // 状态：初始化
    // 执行异步任务
    // 创建 xmlHttp 实例对象
    let xmlHttp = new XMLHttpRequest();
    console.log(xmlHttp.readyState);
    // 绑定监听 readyState
    xmlHttp.onreadystatechange = function() {
      if(xmlHttp.readyState === 4) {
        if(xmlHttp.status === 200) {
          // 修改状态
          resolve(xmlHttp.responseText); // 修改promise的状态为成功的状态
        } else {
          reject('暂时没有新闻内容')
        }
      }
    }

    //open 设置请求的方式以及url
    xmlHttp.open('GET', url);
    // 发送
    xmlHttp.send();
  })
  return promise;
}

getData('http://localhost:3000/news?if=2').then(
  (value) =&gt; {
    console.log(value);
    // 发送请求获取评论内容准备url
    let commentsUrl = JSON.parse(value).commentsUrl;
    let url = 'https://localhost:3000' + commentsUrl;
    // 发送请求
    return getData(url);
  }),
  (reason) =&gt; {
    console.log(reason);
  }
</code></pre>
<h4 id="219-symbol-属性">2.1.9 Symbol 属性</h4>
<p>ES5 中对象的属性名都是字符串，容易造成重名，污染环境。ES6 中添加了一种原始数据类型 symbol。</p>
<p>特点：</p>
<ol>
<li>Symbol 属性值对应的值是唯一的，解决命名冲突问题</li>
<li>Symbol 值不能与其他数据进行计算，包括同字符串拼串</li>
<li>for in，for of 遍历时不会遍历 symbol 属性</li>
</ol>
<p>使用：</p>
<p><strong>1.调用 Symbol 函数得到 symbol 值</strong></p>
<pre><code>// 创建symbol属性值
let symbol = Symbol()
let obj = {username: 'wy', age: 18}
obj[symbol] = 'hi'
console.log(obj) // {username: 'wy', age: 18, symbol(): 'hi'}
// for in，for of 不能遍历symbol属性
for(let i in obj) {
  console.log(i) // username age
}
</code></pre>
<p><strong>2.传参标识</strong></p>
<pre><code>let symbol2 = Symbol('owe')
let symbol3 = Symbol('two')
console.log(symbol2 == symbol3) // false
console.log(symbol2, symbol3) // Symbol(owe) Symbol(two)
// 还可以去定义常量，可以作为当前常量的标识
const Person_key = Symbol('Person_key')
console.log(Person_key) // Symbol(Person_key)
</code></pre>
<p><strong>3.内置 Symbol 值</strong></p>
<p>除了定义自己使用的 Symbol 值以外，ES6 还提供了11个内置 Symbol 值，指向语言内部使用的方法：</p>
<p>Symbol.iterator：对象的 Symbol.iterator 属性，指向该对象的默认遍历方法</p>
<h4 id="2110-iterator-接口机制">2.1.10 iterator 接口机制</h4>
<p>iterator 是一种接口机制，为各种不同的数据结构提供统一的访问机制</p>
<p>作用：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据结构成员能够按某种次序排列</li>
<li>ES6 创造了一种新的遍历命令 for of 循环，Iterator 接口主要供 for of 消费</li>
</ol>
<p>工作原理：</p>
<ul>
<li>
<p>创建一个指针对象（遍历器对象），指向数据结构的起始位置</p>
</li>
<li>
<p>第一次调用 next 方法，指针自动指向数据结构的第一个成员</p>
</li>
<li>
<p>接下来不断调用 next 方法，指针会一直往后移动，直到指向最后一个成员</p>
</li>
<li>
<p>每调用 next 方法返回的是一个包含 value 和 done 的对象，{value: 当前成员的值, done: 布尔值}</p>
<ul>
<li>value 表示当前成员的值，done 对应的布尔值表示当前的数据的结构是否遍历结束</li>
<li>当遍历结束的时候返回的 value 值是 undefined，done 值为 false</li>
</ul>
<p>原生具备 iterator 接口的数据（可用for of遍历）</p>
<p>扩展理解：</p>
<ol>
<li>当数据结构上部署了 Symbol.iterator 接口，该数据就是可以用 for of 遍历</li>
<li>当使用 for of 去遍历目标数据的时候，该数据会自动去找 Symbol.iterator 属性</li>
</ol>
<p>// Symbol.iterator 属性指向对象的默认遍历器方法</p>
<ol>
<li>
<p>Array</p>
</li>
<li>
<p>arguments</p>
</li>
<li>
<p>set 容器</p>
</li>
<li>
<p>map 容器</p>
</li>
<li>
<p>String</p>
<p>...</p>
</li>
</ol>
</li>
</ul>
<pre><code>// 模拟指针对象（遍历器对象）
function myIterator(arr) { // iterator接口
  let nextIndex = 0;
  return { // 遍历器对象
    next: function() {
      return nextIndex &lt; arr.length ? {value: arr[nextIndex++], done: false}:{value: undefined, done: true}
    }
  }
}
// 准备一个数据
let arr = [1, 4, 65, 'abc']
let iteratorObj = myIterator(arr);
console.log(iteratorObj.next()) // {value: 1, done: false}
console.log(iteratorObj.next()) // {value: 4, done: false}
console.log(iteratorObj.next()) // {value: 65, done: false}
console.log(iteratorObj.next()) // {value: &quot;abc&quot;, done: false}
console.log(iteratorObj.next()) // {value: undefined, done: true}
console.log(iteratorObj.next()) // {value: undefined, done: true}
for(let i of arr) {
  console.log(i) // 1 4 65 abc
}
</code></pre>
<p>部署了 iterator 接口的数据类型可以使用 for of 遍历。</p>
<p>这些数据结构已经部署了上面的 iterator：数组、字符串、arguments、set 容器、map 容器</p>
<pre><code>// string可以使用 for of 遍历
let str = 'abcdefg'
for(let i of str) {
  console.log(i) // a b c d e f g
}
// arguments可以使用 for of 遍历
funtion fun() {
    for(let i of aguments) {
    console.log(i) // 1 4 65 abc
  }
}
fun(1, 4, 65, 'abc')
// 但是 arguments不可以使用 for each 遍历（因为它是伪数组）
// object不可以使用 for of 遍历（因为它没有部署iterator接口）
let obj = {username: 'wy', age: 18}
for(let i of obj) {
  console.log(i) // Uncaught TypeError:obj is not iterable
}
</code></pre>
<p>前面 Symbol 属性中提到的：</p>
<p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
<p>其用法：</p>
<pre><code>// 等同于在指定的数据结构上部署了iterator接口
// 当使用for of去遍历某一个数据结构的时候，首先去找Symbol.iterator，找到了就可以遍历，否则不能遍历，报错：xxx is not iterable
let obj = {
    username: 'wy',
    age: 18,
    [Symbol.iterator](){
    let nextIndex = 0;
    return { // 遍历器对象
      next: () =&gt; {
        const arr = Object.values(this)
        return nextIndex &lt; arr.length ? {value: arr[nextIndex++], done: false}:{value: undefined, done: true}
      }
    }
  }
}
for(let i of obj) {
  console.log(i) // wy 18
}
</code></pre>
<p>其实，使用三点运算符、解构赋值时，也默认会调用iterator接口</p>
<h4 id="2111-generator-函数">2.1.11 Generator 函数</h4>
<p>概念：</p>
<ol>
<li>ES6 提供的解决异步编程的方案之一</li>
<li>Generator 函数是一个状态机，内部封装了不同状态的数据</li>
<li>用来生成遍历器对象</li>
<li>可暂停函数（惰性求值），yield 可暂停，next 方法可启动。每次返回的是 yield 后的表达式结果</li>
</ol>
<p>特点：</p>
<ol>
<li>function 与函数名之间有一个星号</li>
<li>内部用 yield 表达式来定义不同的状态</li>
<li>generator 函数返回的是指针对象（iterator），而不会执行函数内部逻辑</li>
<li>调用 next 方法函数内部逻辑开始执行，遇到 yield 表达式停止，返回{value: yield 后的表达式结果/undefined, done:true/false}</li>
<li>再次调用 next 方法会从上一次停止时的 yield 处开始，直到最后</li>
<li>yield 语句返回结果通常为 undefined，当调用 next 方法时传参内容会作为启动时（上一个）yield 语句的返回值</li>
</ol>
<p>简单使用：</p>
<pre><code>function* myGenerator() {
  console.log('开始执行console.log语句不会阻断')
  let result = yield 'hi'; //result的值是从这里启动的next()的参数
  console.log(result)
  console.log('yield后跟一个语句而不是值时')
  yield console.log('console.log会直接打印出来');//yield后跟一个语句时，返回的对象的value就是undefined
  console.log('暂停执行')
  yield 'generator'; //yield后跟一个值时，返回的对象的value就是这个值
  console.log('遍历完毕')
  return '返回结果' //没有return，最后一个yield的value会为undefined
}
// 生成遍历器对象
let MG = myGenerator()
// 执行函数，遇到yield后即暂停
console.log(MG) // 遍历器对象
console.log(MG.next()) // 函数执行。遇到yield暂停
console.log(MG.next('这个值会作为启动时yield语句的返回值'))
console.log(MG.next())
console.log(MG.next())
// 开始执行console.log语句不会阻断
// {value: &quot;hi&quot;, done: false}
// 这个值会作为启动时yield语句的返回值
// yield后跟一个语句而不是值时
// console.log会直接打印出来
// {value: undefined, done: false}
// 暂停执行
// {value: &quot;generator&quot;, done: false}
// 遍历完毕
// {value: &quot;返回结果&quot;, done: true}
</code></pre>
<p>next() 会一直执行直到遇到一个 yield，就会执行其后表达式然后停止在这一步。</p>
<p>对象的 symbol.iterator 属性，指向遍历器对象，结合 generator 的用法：</p>
<pre><code>let obj = {username: 'wy', age: 18}
obj[Symbol.iterator] = function* myTest() {
  yield 1
  yield 2
  yield 3
}
for(let i of obj) {
  console.log(i) // 1 2 3
}
</code></pre>
<p>下面是 Promise 中的案例用 Generator 写的练习（用 setTimeout 来模拟 ajax 请求）</p>
<pre><code>function getData(url) {
  setTimeout(() =&gt; { // 模拟一个get请求
    var news = {id: 1, content: 'lalala', commentsUrl: '/comments?newsId=1'} // 模拟news数据
    var comments = [{comments: 'aaa', newsId: '1'}, {comments: 'bbb', newsId: '1'}] // 模拟comments数据
    if(url === 'http://localhost:3000/news?id=1') { // 假设news数据请求成功
      console.log(`根据${url}获取data内容：${news.content}`)
      let newUrl = `http://localhost:3000/news?id=1${news.commentsUrl}` // 新的url
      SX.next(newUrl) // 将新的url传输出去
    } else if(url === 'http://localhost:3000/news?id=1/comments?newsId=1') { // 假设comments数据请求成功
      console.log(`根据${url}获取data内容：`)
      console.log(comments)
    } else { // 假设请求失败
      console.log('失败')
    }
  }, 2000)
}
function* sendXml() {
  let newUrl = yield getData('http://localhost:3000/news?id=1') // url就是传输过来的新的url
  yield getData(newUrl) // 用新的url再次调用get请求
}
// 获取遍历器对象
let SX = sendXml()
SX.next()
// 根据http://localhost:3000/news?id=1获取data内容：lalala
// 根据http://localhost:3000/news?id=1/comments?newsId=1获取data内容： 
// [{comments: &quot;aaa&quot;, newsId: &quot;1&quot;}, {comments: &quot;bbb&quot;, newsId: &quot;1&quot;}]
</code></pre>
<h4 id="2112-async-函数">2.1.12 async 函数</h4>
<p>概念：真正意义上去解决异步回调的问题，同步流程表达异步操作</p>
<p>本质：Generator 的语法糖</p>
<p>语法：</p>
<pre><code>async function foo() {
    await 异步操作;
  await 异步操作;
}
</code></pre>
<p>特点：</p>
<ol>
<li>不需要像 Generator 去调用 next 方法，遇到 await 等待，当前的异步操作完成就往下执行</li>
<li>返回的总是 Promise 对象，可以用 then 方法进行下一步操作</li>
<li>async 取代 Generator 函数的星号，await 取代 Generator 的 yield</li>
<li>语意上更为明确，使用简单</li>
</ol>
<p>简单使用：</p>
<pre><code>async function foo() {
  return new Promise(resolve =&gt; {
    /*
    setTimeout(() =&gt; {
      resolve()
    }, 2000)
    */
    setTimeout(resolve, 2000) // 简洁写法
  })
}
async function test() {
  console.log('开始执行', new Date().toTimeString())
  await foo();
  console.log('执行完毕', new Date().toTimeString())
}
test()
// 开始执行 01:25:09 GMT+0800 (中国标准时间)
// 执行完毕 01:25:11 GMT+0800 (中国标准时间)
</code></pre>
<p>async 里 await 返回值：</p>
<pre><code>function test2() {
  return 'xxx'
}
async function asyncPrint() {
  let result = await test2();
  let result2 = await Promise.resolve('成功了');
  let result3 = await Promise.reject('失败了');
  console.log(result); // xxx
  console.log(result2); // 成功了
  console.log(result3); // Uncaught (in promise) 失败了
}
asyncPrint();
</code></pre>
<p>还是同一个案例</p>
<pre><code>// 获取新闻内容
async function getNews(url) {
  return new Promise((resolve, reject) =&gt; {
    $.get({
      method: 'GET',
      url,
      success: value =&gt; resolve(value),
      error: reason =&gt; resolve(false)
    })
  })
}

async function sendXml() {
  let result = await getNews('http://localhost:3000/news?id=7');
  console.log(result);
  if(!result) {console.log('暂时没有新闻');return}
  let result = await getNews('http://localhost:3000/news?id=7' + result.commentsUrl);
  console.log(result);
}
sendXml();
</code></pre>
<h4 id="2113-class-类">2.1.13 class 类</h4>
<ol>
<li>通过 class 定义类/实现类的继承</li>
<li>在类中通过 constructor 定义构造方法</li>
<li>通过 new 来创建类的实例</li>
<li>通过 extends 来实现类的继承</li>
<li>通过 super 调用父类的构造方法</li>
<li>重写从父类中继承的一般方法</li>
</ol>
<pre><code>// ES5
function Person(name, age) {
  this.name = name
  this.age = age
}
let person = new Person('wy', 18)
console.log(person)
// ES6
// 定义一个人物的类
class Person {
  // 类的构造方法
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  // 类的一般方法
  showName() {
    console.log('父类方法:', this.name)
  }
}
let person = new Person('wy', 18)
console.log(person)
person.showName() // 父类方法: wy
// 子类
class StarPerson extends Person {
  constructor(name, age, salary) {
    super(name, age) // 调用父类的构造方法
    this.salary = salary
  }
  // 父类的方法重写
  showName() {
    console.log('子类方法:', this.name, this.age, this.salary)
  }
}
let p1 = new StarPerson('wd', 36, 1000)
console.log(p1)
p1.showName() // 子类方法: wd 36 1000
</code></pre>
<h4 id="2114-module-模块化">2.1.14 Module 模块化</h4>
<p>ES6 将一个文件视为一个模块，一个模块中用 export 来导出多个变量或函数。</p>
<pre><code>// 导出变量
export var name = 'Rainbow'
// or
var name = 'Rainbow';
var age = '21';
export {name, age};
// 导出函数
export function myModule(someArgs) {
  return someArgs;
}
</code></pre>
<p>在一个模块中定义好的导出可以在另外一个模块通过 import 引用</p>
<pre><code>import {myModule} from 'main.js';
import {name, age} from 'test.js';
</code></pre>
<p><strong>import 后加花括号{}和不加花括号的区别：</strong></p>
<p><code>export default</code> 命令用于指定模块的默认输出。一个模块只能有一个默认输出，因此 <code>export deault</code> 命令只能使用一次。</p>
<p>所以，import 命令后面才不用加大括号，相反其它的 export 输出可以有多个，且 import 时必须加大括号。</p>
<p>也就是说，通过 <code>import xxx from &quot;...&quot;</code> 引入的，xxx 已经是默认导出项的别名（自己取的其他名字）了。<br>
而 <code>import { xxx } from &quot;...&quot;</code> 引入的，{ xxx } 只是导出项的名字（跟原名一致），而并非导入时的名字。</p>
<h3 id="22-其他">2.2 其他</h3>
<h4 id="221-字符串-数组的扩展">2.2.1 字符串、数组的扩展</h4>
<h5 id="字符串">字符串</h5>
<ol>
<li>includes(str)：判断是否包含指定的字符串</li>
<li>startsWith(str)：判断是否以指定字符串开头</li>
<li>endsWith(str)：判断是否以指定字符串结尾</li>
<li>repeat(count)：重复指定次数</li>
</ol>
<pre><code>let str = 'asdfghjkl'

console.log(str.includes('t')) // false
console.log(str.includes('a')) // true

console.log(str.startsWith('a')) // true
console.log(str.endsWith('l')) // true
console.log(str.repeat(3)) // asdfghjklasdfghjklasdfghjkl
</code></pre>
<h5 id="数值">数值</h5>
<ol>
<li>二进制与八进制数值表示法：二进制用0b，八进制用0o</li>
<li>Number.isFinite(i)：判断是否是有限大的数</li>
<li>Number.isNaN(i)：判断是否是NaN</li>
<li>Number.isInteger(i)：判断是否是整数</li>
<li>Number.parseInt(str)：将字符串转换为对应的数值</li>
<li>Math.trunc(i)：直接去除小数部分</li>
</ol>
<pre><code>console.log(0b1010) // 10
console.log(0o56) // 46

console.log(Number.isFinite(Infinity)) // false
console.log(Number.isNaN(NaN)) // true
console.log(Number.isInteger(123.12)) // false
console.log(Number.isInteger(123.0)) // true

console.log(Number.parseInt('123abc123')) // 123
console.log(Number.parseInt('a123abc123')) // NaN

console.log(Math.trunc(123.123)) // 123
</code></pre>
<h4 id="222-数组方法的扩展">2.2.2 数组方法的扩展</h4>
<ol>
<li>Array.from(v)：将伪数组对象或可遍历对象转换为真数组</li>
<li>Array.of(v1, v2, v3)：将一系列值转换成数组</li>
<li>find(function(value, index, arr) {return true})：找出第一个满足条件返回 true 的元素</li>
<li>findIndex(function(value,index,arr) {return true})：找出第一个满足条件返回 true 的元素下标</li>
</ol>
<pre><code>&lt;button&gt;测试1&lt;/button&gt;
&lt;br&gt;
&lt;button&gt;测试2&lt;/button&gt;
&lt;br&gt;
&lt;button&gt;测试3&lt;/button&gt;
&lt;br&gt;

let btns = document.getElementsByTagName('button') // 获取一个伪数组，没有数组的一般方法
Array.from(btns).forEach(i =&gt; {
    console.log(i)
})

let arr = Array.of(1, 4, 'abc', true)
console.log(arr) // [1, 4, &quot;abc&quot;, true]

let arr2 = [1, 4, 3, 7, 5, 8]
let result = arr2.find((item, index) =&gt; {
  return item &gt; 4
})
console.log(result) // 7
let result2 = arr2.findIndex((item, index) =&gt; {
  return item &gt; 4
})
console.log(result2) // 3
</code></pre>
<h4 id="223-对象方法的扩展">2.2.3 对象方法的扩展</h4>
<ol>
<li>Object.is(v1,v2)：判断2个数据是否完全相等</li>
<li>Object.assign(target,source1,source2..)：将源对象的属性复制到目标对象上</li>
<li>直接操作<code>__proto__</code>属性：<code>let obj2 = {};obj2.__proto__ = obj1;</code></li>
</ol>
<pre><code>console.log(0 == -0) // true
console.log(NaN == NaN) // false(NaN和任何值都不相等)

//Object.is()是以类型和字符串来判断的
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true

let obj = {}
let obj1 = {username: 'wy', age: 18}
let obj2 = {sex: 'male'}
Object.assign(obj, obj1, obj2)
console.log(obj) // {username: 'wy', age: 18, sex: 'male'}

let obj3 = {}
let obj4 = {money: 5000}
obj3.__proto__ = obj4 // 设置obj4为obj3的原型（父类）
console.log(obj3) // {}&gt;__proto__:money: 5000
console.log(obj3.money) // 5000
</code></pre>
<h4 id="224-深度克隆">2.2.4 深度克隆</h4>
<p>浅拷贝和深拷贝针对的是<code>对象/数组</code>，因为基本<code>数据类型</code>没有浅/深一说，它复制都会生成新数据，原数据永远不会被影响。</p>
<blockquote>
<p>深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。</p>
</blockquote>
<p>也就是说：</p>
<p><strong>浅拷贝</strong>：拷贝的引用，修改拷贝后<strong>会影响</strong>原数据，使得原数据不安全</p>
<p><strong>深拷贝(深度克隆)</strong>：拷贝后生成新数据，修改拷贝后<strong>不会影响</strong>原数据</p>
<p>拷贝数据的方法有下面几种：</p>
<h5 id="2241-直接赋值给一个变量浅拷贝">2.2.4.1 直接赋值给一个变量：浅拷贝</h5>
<p>基本数据类型：拷贝后会生成一份新的数据，修改拷贝以后的数据<strong>不会影响</strong>原数据</p>
<p>对象/数组：拷贝后不会生成新的数据，而是复制的引用。修改拷贝后的数据<strong>会影响</strong>原来的数据</p>
<pre><code>// 不会影响原数据 生成新数据
let str = 'abc'
let str2 = str
console.log(str2) // abc
str2 = ''
console.log(str) // abc

let bool1 = true
let bool2 = bool1
bool2 = false
console.log(bool1) // true

// 拷贝数组/对象，没有生成新的数据而是复制了一份引用，改变会影响原数据
let obj = {username: 'wy', age: 18}
let obj1 = obj
console.log(obj1) // {username: 'wy', age: 18}
obj1.username = 'wd'
console.log(obj.username) // wd

let arr = [1, 4, {username: 'wy', age: 18}]
let arr2 = arr
arr2[0] = 'abc'
console.log(arr) // ['abc', 4, {username: 'wy', age: 18}]
</code></pre>
<h5 id="2242-objectassign浅拷贝">2.2.4.2 Object.assign()：浅拷贝</h5>
<p>Object.assign(target,source1,source2..)：将源对象的属性复制到目标对象上，并返回目标对象。</p>
<p><strong>注意： 当对象只有一级属性为深拷贝；当对象中有多级属性时，二级属性后就是浅拷贝</strong></p>
<pre><code>let obj = {username: 'wy', info: {num: 101}}
let obj2 = Object.assign({}, obj)
console.log(obj2) // {username: 'wy', info: {num: 101}}
// 修改obj2中的一级属性，不会影响原数组
obj2.username = 'wd'
console.log(obj) // {username: 'wy', info: {num: 101}}
// 修改obj2中的二级属性，会影响原数组
obj2.info.num = 102
console.log(obj) // {username: 'wy', info: {num: 102}}
</code></pre>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候 obj 与 obj2 指向的是不同的栈对象，所以对 obj.username 重新复制也不会影响到 obj.username。<strong>但是 obj.info 是一个栈对象的引用，而不是一个字符串，那么赋值给 obj2 时，obj2.info 也同样是这个栈对象的引用</strong>。</p>
<h5 id="2243-arrayprototypeconcat浅拷贝">2.2.4.3 Array.prototype.concat()：浅拷贝</h5>
<p>与 Object.assign() 相似，<strong>当数组中的元素均为一维是深拷贝，数组中元素一维以上是值的引用</strong></p>
<pre><code>let arr = [1, 3, {username: 'wy'}, [4]]

// 如果不传参,相当于拷贝了一份
let arr3 = arr.concat() // 还可以写为 let arr3 = [].concat(arr)
console.log(arr3) // [1, 3, {username: 'wy'}, [4]]

// 修改arr3中的一维，不会影响原数组
arr3[1] = 'abc'
arr3.push('test')
console.log(arr) // [1, 3, {username: 'wy'}, [4]]

// 修改arr3中的二维，会影响原数组
arr3[2].username = 'wd'
console.log(arr) // [1, 3, {username: 'wd'}, [4]]
arr3[3].push('test')
console.log(arr) // [1, 3, {username: 'wd'}, [4, &quot;test&quot;]]
</code></pre>
<h5 id="2244-arrayprototypeslice浅拷贝">2.2.4.4 Array.prototype.slice()：浅拷贝</h5>
<p>slice(idx1, idx2)</p>
<p>1）没有参数是拷贝数组</p>
<p>2）只有一个参数是从该位置起到结束拷贝数组元素</p>
<p>3）两个参数，拷贝从起始位置到结束位置的元素（不包含结束位置的元素：含头不含尾）</p>
<p>同样，<strong>当数组中的元素均为一维是深拷贝，数组中元素一维以上是值的引用</strong></p>
<pre><code>let arr = [1, 3, {username: 'wy'}, [4]]
// 返回截取的数组片段
let arr2 = arr.slice(0, 2)
console.log(arr2) // [1, 3]
// 如果不传参,相当于拷贝了一份
let arr3 = arr.slice()
console.log(arr3)// [1, 3, {username: 'wy'}, [4]]

// 修改arr3中的一维，不会影响原数组
arr3[1] = 'abc'
arr3.push('test')
console.log(arr) // [1, 3, {username: 'wy'}, [4]]

// 修改arr3中的二维，会影响原数组
arr3[2].username = 'wd'
console.log(arr) // [1, 3, {username: 'wd'}, [4]]
arr3[3].push('test')
console.log(arr) // [1, 3, {username: 'wd'}, [4, &quot;test&quot;]]
</code></pre>
<h5 id="2245-jsonparsejsonstringify深拷贝">2.2.4.5 JSON.parse(JSON.stringify())：深拷贝</h5>
<pre><code>let arr = [1, 3, {username: 'wy'}]
// 相当于拷贝了一份
let arr2 = JSON.parse(JSON.stringify(arr))
console.log(arr2) // [1, 3, {username: 'wy'}]

// 修改arr2中的基本数据类型number，不会影响原数组
arr2[1] = 'abc'
console.log(arr) // [1, 3, {username: 'wy'}]

// 修改arr2中的Object类型，不会影响原数组
arr2[2].username = 'wd'
console.log(arr, arr2) // [1, 3, {username: 'wy'}] [1, 3, {username: 'wd'}]
</code></pre>
<blockquote>
<p>需要注意的是：这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefined，function函数）</p>
</blockquote>
<p>更重要的是，这种方法只能克隆原始对象自身的值，不能克隆它继承的值，参考如下代码：</p>
<pre><code>var clone = function (obj) {
  return JSON.parse(JSON.stringify(obj));
}
function Person (name) {
  this.name = name
}
Person.prototype = {
  age: 18,
}
var wanger = new Person('王二')
var newwanger = clone(wanger)
console.log(wanger) // Person {name: &quot;王二&quot;, __proto__: {age: 18}}
console.log(newwanger) // {name: &quot;王二&quot;}
wanger instanceof Person // true
newwanger instanceof Person // false
newwanger instanceof Object // true
</code></pre>
<p>克隆的对象的构造函数已经变成了 Object，而原来的对象的构造是 Person。</p>
<h4 id="225-如何实现深度拷贝克隆">2.2.5 如何实现深度拷贝（克隆）</h4>
<p>拷贝的数据都是基本数据时，确保都是深度克隆，不会影响到原数据。</p>
<p>如果有对象/数组，可以遍历它们，拿到里面的每一项值，直到拿到的是基本数据类型，然后再去复制，可以实现对象/数组的深度拷贝。</p>
<h5 id="知识点储备">知识点储备</h5>
<p>如何判断数据类型：arr ---&gt; Array，null ---&gt; Null</p>
<ol>
<li>**typeOf 返回的数据类型：**String，Number，Boolean，Undefined，Object（null也会返回一个Object，因为null默认是一个空对象），Function</li>
<li>Object.prototype.toString()</li>
</ol>
<pre><code>let result = 'abc'
console.log(Object.prototype.toString.call(result)) // [object String]
result = null
console.log(Object.prototype.toString.call(result)) // [object Null]
result = [1, 2, 3]
console.log(Object.prototype.toString.call(result)) // [object Array]
console.log(Object.prototype.toString.call(result).slice(8, -1)) // Array
</code></pre>
<ol>
<li>for in 循环 对象(属性名) 数组(下标)</li>
</ol>
<pre><code>let obj = {username: 'wy', age: 18}
for(let i in obj) {
  console.log(i) // username age
}
let arr = [1, 3, 'abc']
for(let i in arr) {
  console.log(i) // 0 1 2
}
</code></pre>
<p>完整实现深度克隆：</p>
<pre><code>// 定义检测数据类型的功能函数
function checkedType(target) {
  return Object.prototype.toString.call(target).slice(8, -1)
}
// 实现深度克隆 ---&gt; 对象/数组
function clone(target) {
  // 判断拷贝的数据类型
  // 初始化变量result成为最终克隆的数据
  let result, targetType = checkedType(target);
  if(targetType === 'Object') {
    result = {};
  } else if(targetType === 'Array') {
    result = [];
  } else {
    return target;
  }
  // 遍历目标数据
  for(let i in target) {
    // 获取遍历数据结构的每一项值
    let value = target[i];
    // 判断目标结构里的每一项值是否存在对象/数组
    if(checkedType(value) === 'Object' || checkedType(value) === 'Array') { // 对象/数组中又嵌套着对象/数组
      // 继续遍历获取到的value
      result[i] = clone(value);
    } else { //　获取到的value是基本的数据类型或函数
      result[i] = value;
    }
  }
  return result;
}
let arr = [1, 3, [5, 7, {username: 'wy', age: 18}, 15], 9]
let arr2 = clone(arr)
console.log(arr2) // [1, 3, [5, 7, {username: 'wy', age: 18}, 15], 9]
arr2[2][2].username = 'wd'
console.log(arr, arr2) // [1, 3, [5, 7, {username: 'wy', age: 18}, 15], 9] [1, 3, [5, 7, {username: 'wd', age: 18}, 15], 9]

let obj = {username: 'wy', age: 18}
let obj2 = clone(obj)
console.log(obj2) // {username: &quot;wy&quot;, age: 18}
obj2.username = 'wd'
console.log(obj, obj2) //{username: &quot;wy&quot;, age: 18} {username: &quot;wd&quot;, age: 18}
</code></pre>
<h4 id="226-set-和-map-数据结构">2.2.6 Set 和 Map 数据结构</h4>
<h5 id="set-容器">Set 容器</h5>
<p>无序不可重复的多个 value 的集合体</p>
<ul>
<li>Set()</li>
<li>Set(array)</li>
<li>add(value)：添加</li>
<li>delete(value)：删除</li>
<li>has(value)：判断有没有</li>
<li>clear()：清空</li>
<li>size：有几个（相当于length）</li>
</ul>
<pre><code>let set = new Set([1, 2, 4, 5, 2, 3, 6])
console.log(set) // Set(6) {1, 2, 4, 5, 3, 6}
// 重复的2被删去了
set.add(7)
console.log(set.size, set) // 7 Set(7) {1, 2, 4, 5, 3, 6, 7}

console.log(set.has(8)) // false
console.log(set.has(7)) // true

set.clear()
console.log(set) // Set(0) {}
</code></pre>
<p>用 Set 去重：</p>
<pre><code>let arr1 = [1, 2, 4, 5, 5, 6, 8, 2]
let arr = [... new Set(arr1)]
console.log(arr) // [1, 2, 4, 5, 6, 8]
</code></pre>
<h5 id="map-容器">Map 容器</h5>
<p>无序的 key 不重复的多个 key-value 的集合体</p>
<ul>
<li>Map()</li>
<li>Map(array)</li>
<li>set(key,value)：添加</li>
<li>get(key)</li>
<li>delete(key)：删除</li>
<li>has(key)</li>
<li>clear()</li>
<li>size</li>
</ul>
<pre><code>let map = new Map([ ['aaa', 'username'], [36, 'age'] ])
// 添加
map.set(78, 'hh')
console.log(map) // Map(3) {&quot;aaa&quot; =&gt; &quot;username&quot;, 36 =&gt; &quot;age&quot;, 78 =&gt; &quot;hh&quot;}
// 删除
map.delete(36)
console.log(map) // Map(2) {&quot;aaa&quot; =&gt; &quot;username&quot;, 78 =&gt; &quot;hh&quot;}
</code></pre>
<h4 id="227-for-of-用法">2.2.7 for of 用法</h4>
<p>for(let value of target) {} 循环遍历（必须部署 iterator）</p>
<ol>
<li>遍历数组</li>
<li>遍历 Set</li>
<li>遍历 Map</li>
<li>遍历字符串</li>
<li>遍历伪数组</li>
</ol>
<p>前面 Set 去重的方法用 for of 可以这样写：</p>
<pre><code>let arr1 = [1, 2, 4, 5, 5, 6, 8, 2]
let arr = []
let set = new Set(arr1)
for(let i of set) {
  arr.push(i) 
}
console.log(arr) // [1, 2, 4, 5, 6, 8]
</code></pre>
<h2 id="三-es7">三、ES7</h2>
<ol>
<li>指数运算符<code>**</code>（幂）</li>
</ol>
<pre><code>console.log(3 ** 3) // 27
</code></pre>
<ol>
<li>
<p>Array.prototype.includes(value)：判断数组中是否包含指定 value</p>
<blockquote>
<p>ES6 中只有 String 的 includes，ES7 中补上了 Array 的 includes</p>
</blockquote>
</li>
</ol>
<pre><code>let arr = [1, 4, 5, 6, 'abc']
console.log(arr.includes('a')) // false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>http://alfy20.github.io/post/hello-gridea/</id>
        <link href="http://alfy20.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>